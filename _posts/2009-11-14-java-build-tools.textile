---
categories: work
date: November 14, 2009
layout: article
title: "Java Build Tools: Ant vs. Maven"
---

_*TRANSLATIONS:* "Spanish":spanish (gracias, Jos&eacute;!)_

_*UPDATED 2010-01-06:* linked to demonstration of the "10 minute mvn clean build" problem, and added notes about: slow build times, excessive memory use, bad test result output, untrusted repository artifacts, and external configuration files._

_*UPDATED 2010-02-21:* linked to Spanish translation provided by Jos&eacute; Manuel Prieto_

The best build tool is the one you write yourself.  Every project's build process is unique, and often individual projects need to be built multiple different ways.  It is impossible for tool authors to anticipate every build's requirements, and foolhardy to try ("Apache":apache developers: take note).  The best any tool can do is provide a flexible library of reusable tasks that can easily be adapted to your needs, but even that is insufficient.  Off-the-shelf tasks never suit your project perfectly.  You will waste countless hours struggling to make those tasks do _exactly_ what you need, only to give up and write a plugin instead.  Writing your own custom build tool is quick and easy, and requires less maintenance than you fear.  Don't be afraid: builds should fit your project, not the other way around.

If you don't want to write your own build tool, then you should use "Rake":rake.  "Rake":rake is the best existing build tool for Java projects.  "Rake":rake provides a bunch of standard methods to perform common build tasks, and anything else can be quickly implemented in "Ruby":ruby.  Writing build scripts in a real programming language gives "Rake":rake a huge advantage over other tools.  There are other advantages, too, but none are as important.

So, you should write custom build tools for your projects.  If you don't want to, then you should switch to "Rake":rake.  If you can't switch, you should lobby for the right to switch.  If politics drives technology decisions, if you will never be allowed to switch, then quit your job or leave the project.

If you lack the courage to quit, then use "Ant":ant.  "Ant":ant is the second best existing build tool for Java projects.  Although inferior to "Rake":rake, "Ant":ant is still a great build tool.  "Ant":ant is mature and stable, it is fast, and it comes with a rich library of tasks.  "Ant":ant makes it possible (but "not at all easy":http://alex-verkhovsky.blogspot.com/2009/03/lets-use-real-languages-for-builds.html) to script rich, complex builds processes custom-tailored to your project.

So, write your own build tool, or else switch to "Rake":rake, or fight to switch to "Rake":rake, or quit and go some place where you can use "Rake":rake.  And if all else fails, use "Ant":ant until you can find a new job somewhere else that uses "Rake":rake.

That's it!  Those are the *only* choices I can recommend!  Because you never, *ever*, under _any_ circumstances want to use "Maven":maven!

"Maven":maven builds are an infinite cycle of despair that will slowly drag you into the deepest, darkest pits of hell (where "Maven":maven itself was forged).  You will initially only spend ten minutes getting "Maven":maven up and running, and might even be happy with it for a while.  But as your project evolves, and your build configuration grows, the basic "pom.xml":pom that you started with will prove inadequate.  You will slowly add more configuration to get things working the way you need, but there's only so much you can configure in "Maven":maven.  Soon, you will encounter "Maven's":maven low glass ceiling for the first time.  By "encounter," I mean "smash your head painfully against."  By "for the first time," I mean "you will do this repeatedly and often in the future."  Eventually, you'll figure out some convulted "pom.xml":pom hackery to work around your immediate issue.  You might even be happy with "Maven":maven again for a while... until another limitation rears its ugly little head.  It's a lot like some tragic Greek myth, only you are the damned soul and the eternity of suffering is your build process.

Seriously.  "Maven":maven is a _horrible_ implementation of _bad_ ideas.  I believe someone, somewhere had (perhaps still has) a vision for "Maven":maven that was sensible, if not seductive.  But the actual implementation of "Maven":maven lacks any trace of such vision.  In fact, everything in "Maven":maven is so bad that it serves as a valuable example of how _not_ to build software.  You know your build is awesome when it works the opposite of "Maven":maven.

Consider the test results output from "Maven's":maven "Surefire plugin":surefire.  Everything seems fine as long as all of your tests are passing, but "Surefire":surefire reports are a _nightmare_ to debug when things go wrong!  The only information logged to the console is the name of the failing test class.  You must _manually_ cross-reference that name with a log file written in the @target/surefire-reports/@ directory, but those logs are written _one per test class_!  So, if multiple test classes fail, you must separately check multiple log files.  It seems like a minor thing, but it quickly adds up to a major annoyance and productivity sink.

"Maven":maven advocates claim their tool embraces the principle of _"Convention Over Configuration":http://www.sonatype.com/books/maven-book/reference/installation-sect-conventionConfiguration.html_; "Maven":maven advocates are liars.  The only convention "Maven":maven supports is: "compile, run unit tests, package .jar file":http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html.  Getting "Maven":maven to do _anything_ else requires  _configuring_ the conventions.  Want to package a .war file?  "Configure it":http://maven.apache.org/plugins/maven-war-plugin/index.html.  Want to run your application from the command line?  "Configure it":http://mojo.codehaus.org/exec-maven-plugin/java-mojo.html.  Want to run acceptance tests or functional tests or performance tests with your build, too?   You can "configure it":http://docs.codehaus.org/display/MAVENUSER/Maven+and+Integration+Testing, but it involves *not* running your unit tests, or not running them during the _conventional_ unit test phase of your build process, or...  Want to generate code coverage metrics for your project?  You can "configure that":http://mojo.codehaus.org/cobertura-maven-plugin/index.html, too, but your tests will run _twice_ (or only once, but not during the _conventional_ unit test phase), and sometimes it reports 0% code coverage despite the comprehensive test suite.

Speaking of configuration, "Maven":maven has the worst configuration syntax since "Sendmail":http://www.sendmail.org: "alternating normal form":http://www.ltg.ed.ac.uk/~ht/normalForms.html "XML":xml.  As a consequence, "Maven":maven configuration is verbose, difficult to read and difficult to write.  Things you can do in one or two lines of "Ruby":ruby or "XML":xml with "Rake":rake or "Ant":ant require six, seven, eight lines of "pom.xml":pom configuration (assuming it's even _possible_ with "Maven":maven).

There's nothing consistent about "Maven's":maven configuration, either.  Some things are configured as classpath references to .properties files bundled in .jar files configured as dependencies, some things are configured as absolute or relative paths to files on disk, and some things are configured as system properties in the JVM running "Maven":maven.  And some of those absolute paths are portable across projects because "Maven":maven knows how to correctly resolve them, but some are not.  And sometimes "Maven":maven is smart enough to recursively build projects in the correct order, but sometimes it's not.

And some things aren't even configured in the "pom":pom!  Some things, like "Maven repositories":http://maven.apache.org/repository-management.html, servers, and authentication credentials, are configured in "settings.xml":settings.  It is perfectly reasonable to want to keep user's passwords out of "pom.xml":pom files which will be checked into the project's version control repository.  But "Maven's":maven solution is terrible: all this configuration goes in a "settings.xml":settings file that lives outside of any project's directory.  You can't directly share any of this configuration between your desktop and laptop, or with other developers, or with your project's build servers.  But it _is_ *automatically* shared with _every_ single "Maven":maven project you work with, and potentially every single "Maven":maven project _every user_ on that machine works with.  When a new developer joins your project, they must _manually_ merge the necessary configuration into their existing "settings.xml":settings.  When a new agent is added to your build server farm, the necessary configuration is _manually_ merged into its existing "settings.xml":settings.  Ditto for when you migrate to a new machine.  And when _any_ of this configuration needs to be updated, it must be _manually_ updated on _every_ single machine!  This was a solved problem before "Maven":maven came along, too: properties files.  Project teams can put generic configuration like this in a properties file which is checked in to version control, and individual developers can override that information in local properties file which are not checked in to version control.

All this stuff in "Maven":maven -- the conventions, the configuration, the process -- is governed by "The Maven Way".  Unfortunately, "The Maven Way" is undocumented.  You can catch fleeting glimpses of it by trawling the "Maven documentation":maven, searching the "Google":http://www.google.com, or buying books written by "Maven developers":http://maven.apache.org/team-list.html.  The other way you encounter "The Maven Way" is by tripping over (or smashing against) its invisible boundaries.  "Maven":maven was not built to be flexible, and it does _not_ support every possible build process.  "Maven":maven was built for "Apache":apache projects, and assumes every project's build process mirrors "Apache's":apache own.  That's great news for open-source library developers who volunteer on their own time and to whom "release" means "upload a new .zip file to your website for others to manually find, download, and add to their own projects."  It sucks for everyone else.  While "Rake":rake and "Ant":ant can accommodate every build process, "Maven":maven can't; it is possible, and in fact quite likely, that "Maven":maven just doesn't support the way you want to build your software.

And "Maven's":maven dependency management is completely, entirely, irrevocably broken.  Actually, I take that back; "Maven's":maven strategy of  downloading "ibiblio":http://ibiblio.org to the user's home directory and then dumping everything on the classpath is incredibly stupid and wrong and should never be confused with "dependency management."  I recently worked on a "Maven":maven project which produced a 51 MB .war file; by switching to "Ant":ant with hand-rolled dependency management, we shrunk that .war file down to 17 MB.  Hrmmm... 51 - 17 = 34 = 17 x 2, or: 2/3 of the original bulk was useless crap "Maven":maven dumped on us.

Extraneous dependencies don't just eat up disk space, they eat up precious RAM, too!  "Maven":maven is an all-around memory hog.  Relatively simple projects, with only a parent "pom":pom and a few sub-modules, require extensive JVM memory tuning with all those fancy @JAVA_OPTS@ settings you typically only see on production servers.  Things are even worse if your "Maven":maven build is integrated with your IDE.  It's common to set your JVM's max heap size to several hundred megabytes, the max permgen size to a few hundred megabytes, and enable permgen sweeping so classes themselves are garbage collected.  And all this just to build your project, or work with "Maven":maven in your IDE!

Funny story: on that same project I once endured a ten minute "mvn clean" build because "Maven":maven thought it needed yet more crap in order to "rm -rf ./target/" (see a similar example: "http://gist.github.com/267553":http://gist.github.com/267553).  Actually, there's nothing funny about that story; trust me: you don't want a build tool which automatically downloads unresolved dependencies before cleaning out your build output directories.  You don't want a build tool which automatically downloads unresolved dependencies, *PERIOD*!  Automatically downloading unresolved dependencies makes your build process _nondeterministic_!  Good ol' nondeterminism: loads of fun in school, not so fun at work!

And all that unnecessary, unwanted network chatter takes time.  You pay a performance penalty for "Maven's":maven broken dependency management on every build.  Ten minute clean builds are horrible, but adding an extra minute to _every_ build is even worse!  I estimate the average additional overhead of "Maven":maven is about one minute per build, based on the fact that the one time I switched from "Maven":maven to "Ant":ant the average build time dropped from two and a half minutes to one and a half.  Similarly, the one time I switched from "Ant":ant to "Maven":maven the average build time increased from two minutes to three.

You have no control over, and limited visibility into, the dependencies specified by your dependencies.  Builds _will_ break because different copies of "Maven":maven _will_ download different artifacts at different times; your local build _will_ break again in the future when the dependencies of your dependencies accidentally release new, non-backwards compatible changes without remembering to bump their version number.  Those are just the innocent failures, too; the far more likely scenario is your project depends on a specific version of some other project which in turn depends on the LATEST version of some other project, so you still get hosed even when downstream providers _do_ remember to bump versions!  Every release of every dependency's dependencies becomes a new opportunity to waste several hours tracking down strange build failures.

But "Maven":maven is even worse than that: not only does "Maven":maven automatically resolve your project's dependencies, it automatically resolves its own plugins' dependencies, too!  So now not only do you have to worry about separate instances of "Maven":maven accidentally downloading incompatible artifacts (or the same instance downloading incompatible artifacts at different times), you also have to worry about your build tool itself behaving differently across different machines at different times!

"Maven's":maven broken dependency management is also a gaping security hole, since it is currently impossible in "Maven":maven to determine where artifacts originally came from and whether or not they were tampered with.  Artifacts are automatically checksummed when they are uploaded to a repository, and "Maven":maven automatically verifies that checksum when it downloads the artifact, but "Maven":maven implicitly trusts the checksum on the repository it downloaded the artifact from.  The current extent of "Maven":maven artifact security is that the "Maven":maven developers control who has write access to the authoritative repository at "ibiblio":http://www.ibiblio.org/maven/.  But there is no way of knowing if the repository you download all your dependencies from was poisoned, there is no way of knowing if your local repository cache was poisoned, and there is no way of knowing which repository artifacts in your local repository cache came from or who uploaded them there.

These problems are not caused by careless developers, and are not solved by using "repository managers":http://maven.apache.org/repository-management.html to lock down every artifact "Maven":maven needs.  "Maven":maven is broken and wrong if it assumes humans never make mistakes.  "Maven":maven is broken and wrong if it requires users to explicitly specify every version of every dependency, and every dependency's dependencies, to reduce the likelihood of downloading incompatible artifacts.  "Maven":maven is broken and wrong if it requires a third-party tool to prevent it connecting to the big, bad internets and automatically downloading random crap.  "Maven":maven is broken and wrong if it thinks nothing of slowing down _every_ build by connecting to the network and checking _every_ dependency for _any_ updates, and automatically downloading them.  "Maven":maven is broken and wrong if it behaves differently on my laptop at the office and at home.  "Maven":maven is broken and wrong if it requires an internet connection to delete a directory.  "Maven":maven is broken and wrong.

"Save":rake "yourself":ant.

[ant]http://ant.apache.org
[apache]http://jakarta.apache.org
[java]http://java.sun.com
[maven]http://maven.apache.org
[pom]http://maven.apache.org/guides/introduction/introduction-to-the-pom.html
[rake]http://rake.rubyforge.org
[ruby]http://www.ruby-lang.org
[settings]http://maven.apache.org/settings.html
[surefire]http://maven.apache.org/plugins/maven-surefire-plugin/
[xml]http://www.xml.com

[spanish]http://prietopa.wordpress.com/2010/01/29/herramientas-de-construccion-de-java-ant-vs-maven/
