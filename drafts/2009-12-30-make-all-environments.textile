---
categories: work
date: December 30, 2009
layout: article
title: "Make All Environments Consistent"
---

Consistent environments are important on software projects.  They increase the team's productivity, make it easier to diagnose, replicate and resolve bugs, make it easier to tune performance and scale the application, and reduce the cost of administration and maintenance.  Building consistent environments is a great candidate for automation; in fact, tools like "Chef":chef and "Puppet":puppet were written for exactly this purpose.  But Chef and Puppet are complicated, heavyweight solutions.  They also require a considerable amount of infrastructure themselves ("git":git, "Ruby":ruby, etc.)!

For lighter, simpler configuration needs I prefer "Makefiles":make.  Makefiles are a great option because "Make":make is installed by default on modern UNIX platforms (except, perhaps, "Ubuntu":ubuntu), and can be installed without additional dependencies everywhere else.  Makefile syntax is already familiar to most system administrators and easy to learn, and because Makefiles are "shell scripts":sh with a few format constraints they map directly to the sequence of steps you would perform manually to setup your environments.  But arguably the biggest advantage of Makefiles is they won't do anything when the file about to be installed or modified exists.  This is critical in shared production environments where services might already be installed and configured for other applications, and you don't want to risk accidentally overwriting something important.

Consider an application that requires "Java":java and "JRuby":jruby, and a convention that third-party applications like these should be installed under @/opt/apps/<name>/<name>-<version>@.  The following Makefile installs and configures Java and JRuby according to these conventions:

<pre><code>
# Makefile

JAVA_VERSION=1.6.0_18
JRUBY_VERSION=1.4.0

# TARGET 0:
all: java jruby

# TARGET 1:
java: /opt/apps/java/java-${JAVA_VERSION}

# TARGET 2:
jruby: /opt/apps/jruby/jruby-${JRUBY_VERSION}

# TARGET 3:
/opt/apps/java/java-${JAVA_VERSION}/: /opt/apps/java/ /tmp/java-${JAVA_VERSION}.tar.gz
	(cd /opt/apps/java; tar czf /tmp/java-${JAVA_VERSION}.tar.gz)

# TARGET 4:
/opt/apps/jruby/jruby-${JRUBY_VERSION}/: /opt/apps/jruby/ /tmp/jruby-${JRUBY_VERSION}.tar.gz
	(cd /opt/apps/jruby; tar czf /tmp/jruby-${JRUBY_VERSION}.tar.gz)

# TARGET 5:
/opt/apps/java/: /opt/apps/
	mkdir /opt/apps/java

# TARGET 6:
/opt/apps/jruby/: /opt/apps/
	mkdir /opt/apps/jruby

# TARGET 7:
/tmp/java-${JAVA_VERSION}.tar.gz:
	# Shell commands to download Java

# TARGET 8:
/tmp/jruby-${JRUBY_VERSION}.tar.gz:
	# Shell commands to download JRuby

# TARGET 9:
/opt/apps/:
	mkdir -p /opt/apps

</code></pre>

Target 0, named @all@ here but could be named anything, is the default target because it is the first target in the Makefile; if you are in the directory containing this Makefile, simply typing @make@ would be equivalent to @make all@.

Make is a file-centric build tool; it assumes the purpose of each target is to produce (or "make," natch) a single file.  By convention, the name of the target is the name of the output file produced by invoking that target.  For example, Make assumes this is different than "Rake":rake or "Ant":ant.

[ant]http://ant.apache.org
[chef]http://wiki.opscode.com/display/chef/Home
[git]http://www.git-scm.com
[java]http://java.sun.com
[jruby]http://jruby.org
[make]http://www.opengroup.org/onlinepubs/009695399/utilities/make.html
[puppet]http://reductivelabs.com/products/puppet/
[rake]http://rake.rubyforge.org
[ruby]http://www.ruby-lang.org
[sh]http://www.opengroup.org/onlinepubs/009695399/utilities/sh.html
[ubuntu]http://www.ubuntu.com
