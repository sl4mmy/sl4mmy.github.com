---
categories: work
date: November 14, 2009
layout: article
title: "Java Build Tools: Ant vs. Maven"
---

The best build tool is the one you write yourself.  Every project's build process is unique, and often individual projects need to be built multiple different ways.  It is impossible for tool authors to anticipate every build's requirements, and foolhardy to try ("Apache":apache developers: take note).  The best any tool can do is provide a flexible library of reusable tasks that can easily be adapted to your needs, but even that is insufficient.  Off-the-shelf tasks never suit your project perfectly.  You will waste countless hours struggling to make those tasks do _exactly_ what you need, only to give up and write a plugin instead.  Writing your own custom build tool is quick and easy, and requires less maintenance than you fear.  Don't be afraid: builds should fit your project, not the other way around.

If you don't want to write your own build tool, then you should use "Rake":rake.  "Rake":rake is the best existing build tool for Java projects.  "Rake":rake provides a bunch of standard methods to perform common build tasks, and anything else can be quickly implemented in "Ruby":ruby.  Writing build scripts in a real programming language gives "Rake":rake a huge advantage over other tools.  There are other advantages, too, but none are as important.

So, you should write custom build tools for your projects.  If you don't want to, then you should switch to "Rake":rake.  If you can't switch, you should lobby for the right to switch.  If politics drives technology decisions, if you will never be allowed to switch, then quit your job or leave the project.

If you lack the courage to quit, then use "Ant":ant.  "Ant":ant is the second best existing build tool for Java projects.  Although inferior to "Rake":rake, "Ant":ant is still a great build tool.  "Ant":ant is mature and stable, it is fast, and it comes with a rich library of tasks.  "Ant":ant makes it possible (but "not at all easy":http://alex-verkhovsky.blogspot.com/2009/03/lets-use-real-languages-for-builds.html) to script rich, complex builds processes custom-tailored to your project.

So, write your own build tool, or else switch to "Rake":rake, or fight to switch to "Rake":rake, or quit and go some place where you can use "Rake":rake.  And if all else fails, use "Ant":ant until you can find a new job somewhere else that uses "Rake":rake.

That's it!  Those are the *only* choices I can recommend!  Because you never, *ever*, under _any_ circumstances want to use "Maven":maven!

"Maven":maven builds are an infinite cycle of despair that will slowly drag you into the deepest, darkest pits of hell (where "Maven":maven itself was forged).  You will initially only spend ten minutes getting "Maven":maven up and running, and might even be happy with it for a while.  But as your project evolves, and your build configuration grows, the basic "pom.xml":pom that you started with will prove inadequate.  You will slowly add more configuration to get things working the way you need, but there's only so much you can configure in "Maven":maven.  Soon, you will encounter "Maven's":maven low glass ceiling for the first time.  By "encounter," I mean "smash your head painfully against."  By "for the first time," I mean "you will do this repeatedly and often in the future."  Eventually, you'll figure out some convulted "pom.xml":pom hackery to work around your immediate issue.  You might even be happy with "Maven":maven again for a while... until another limitation rears its ugly little head.  It's a lot like some tragic Greek myth, only you are the damned soul and the eternity of suffering is your build process.

Seriously.  "Maven":maven is a _horrible_ implementation of _bad_ ideas.  I believe someone, somewhere had (perhaps still has) a vision for "Maven":maven that was sensible, if not seductive.  But the actual implementation of "Maven":maven lacks any trace of such vision.  In fact, everything in "Maven":maven is so bad that it serves as a valuable example of how _not_ to build software.  You know your build is awesome when it works the opposite of "Maven":maven.

"Maven":maven advocates claim their tool embraces the principle of _"Convention Over Configuration":http://www.sonatype.com/books/maven-book/reference/installation-sect-conventionConfiguration.html_; "Maven":maven advocates are liars.  The only convention "Maven":maven supports is: "compile, run unit tests, package .jar file":http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html.  Getting "Maven":maven to do _anything_ else requires  _configuring_ the conventions.  Want to package a .war file?  "Configure it":http://maven.apache.org/plugins/maven-war-plugin/index.html.  Want to run your application from the command line?  "Configure it":http://mojo.codehaus.org/exec-maven-plugin/java-mojo.html.  Want to run acceptance tests or functional tests or performance tests with your build, too?   You can "configure it":http://docs.codehaus.org/display/MAVENUSER/Maven+and+Integration+Testing, but it involves *not* running your unit tests, or not running them during the _conventional_ unit test phase of your build process, or...  Want to generate code coverage metrics for your project?  You can "configure that":http://mojo.codehaus.org/cobertura-maven-plugin/index.html, too, but your tests will run _twice_ (or only once, but not during the _conventional_ unit test phase), and sometimes it reports 0% code coverage despite the comprehensive test suite.

Speaking of configuration, "Maven":maven has the worst configuration syntax since "Sendmail":http://www.sendmail.org: "alternating normal form":http://www.ltg.ed.ac.uk/~ht/normalForms.html "XML":xml.  As a consequence, "Maven":maven configuration is verbose, difficult to read and difficult to write.  Things you can do in one or two lines of "Ruby":ruby or "XML":xml with "Rake":rake or "Ant":ant require six, seven, eight lines of "pom.xml":pom configuration (assuming it's even _possible_ with "Maven":maven).

There's nothing consistent about "Maven's":maven configuration, either.  Some things are configured as classpath references to .properties files bundled in .jar files configured as dependencies, some things are configured as absolute or relative paths to files on disk, and some things are configured as system properties in the JVM running "Maven":maven.  And some of those absolute paths are portable across projects because "Maven":maven knows how to correctly resolve them, but some are not.  And sometimes "Maven":maven is smart enough to recursively build projects in the correct order, but sometimes it's not.

All this stuff in "Maven":maven -- the conventions, the configuration, the process -- is governed by "The Maven Way".  Unfortunately, "The Maven Way" is undocumented.  You can catch fleeting glimpses of it by trawling the "Maven documentation":maven, searching the "Google":http://www.google.com, or buying books written by "Maven developers":http://maven.apache.org/team-list.html.  The other way you encounter "The Maven Way" is by tripping over (or smashing against) its invisible boundaries.  "Maven":maven was not built to be flexible, and it does _not_ support every possible build process.  "Maven":maven was built for "Apache":apache projects, and assumes every project's build process mirrors "Apache's":apache own.  That's great news for open-source library developers who volunteer on their own time and to whom "release" means "upload a new .zip file to your website for others to manually find, download, and add to their own projects."  It sucks for everyone else.  While "Rake":rake and "Ant":ant can accommodate every build process, "Maven":maven can't; it is possible, and in fact quite likely, that "Maven":maven just doesn't support the way you want to build your software.

And "Maven's":maven dependency management is completely, entirely, irrevocably broken.  Actually, I take that back; "Maven's":maven strategy of  downloading "ibiblio":http://ibiblio.org to the user's home directory and then dumping everything on the classpath is incredibly stupid and wrong and should never be confused with "dependency management."  I recently worked on a "Maven":maven project which produced a 51 MB .war file; by switching to "Ant":ant with hand-rolled dependency management, we shrunk that .war file down to 17 MB.  Hrmmm... 51 - 17 = 34 = 17 x 2, or: 2/3 of the original bulk was useless crap "Maven":maven dumped on us.

Funny story: on that same project I once endured a ten minute "mvn clean" build because "Maven":maven thought it needed yet more crap in order to "rm -rf ./target/".  Actually, there's nothing funny about that story; trust me: you don't want a build tool which automatically downloads unresolved dependencies before cleaning out your build output directories.  You don't want a build tool which automatically downloads unresolved dependencies, *PERIOD*!  Automatically downloading unresolved dependencies makes your build process _nondeterministic_!  Good ol' nondeterminism: loads of fun in school, not so fun at work!

You have no control over, and limited visibility into, the dependencies specified by your dependencies.  Builds _will_ break because different copies of "Maven":maven _will_ download different artifacts at different times; your local build _will_ break again in the future when the dependencies of your dependencies accidentally release new, non-backwards compatible changes without remembering to bump their version number.  Those are just the innocent failures, too; the far more likely scenario is your project depends on a specific version of some other project which in turn depends on the LATEST version of some other project, so you still get hosed even when downstream providers _do_ remember to bump versions!  Every release of every dependency's dependencies becomes a new opportunity to waste several hours tracking down strange build failures.

But "Maven":maven is even worse than that: not only does "Maven":maven automatically resolve your project's dependencies, it automatically resolves its own plugins' dependencies, too!  So now not only do you have to worry about separate instances of "Maven":maven accidentally downloading incompatible artifacts (or the same instance downloading incompatible artifacts at different times), you also have to worry about your build tool itself behaving differently across different machines at different times!

These problems are not caused by careless developers, and are not solved by using "repository managers":http://maven.apache.org/repository-management.html to lock down every artifact "Maven":maven needs.  "Maven":maven is broken and wrong if it assumes humans never make mistakes.  "Maven":maven is broken and wrong if it requires users to explicitly specify every version of every dependency, and every dependency's dependencies, to reduce the likelihood of downloading incompatible artifacts.  "Maven":maven is broken and wrong if it requires a third-party tool to prevent it connecting to the big, bad internets and automatically downloading random crap.  "Maven":maven is broken and wrong if it thinks nothing of slowing down _every_ build by connecting to the network and checking _every_ dependency for _any_ updates, and automatically downloading them.  "Maven":maven is broken and wrong if it behaves differently on my laptop at the office and at home.  "Maven":maven is broken and wrong if it requires an internet connection to delete a directory.  "Maven":maven is broken and wrong.

"Save yourself":rake.

[ant]http://ant.apache.org
[apache]http://jakarta.apache.org
[java]http://java.sun.com
[maven]http://maven.apache.org
[pom]http://maven.apache.org/guides/introduction/introduction-to-the-pom.html
[rake]http://rake.rubyforge.org
[ruby]http://www.ruby-lang.org
[xml]http://www.xml.com
